
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Jun 22 21:20:42 CEST 2015
//----------------------------------------------------

package net.etfbl.kki;

import java_cup.runtime.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.mj.runtime.Code;
import java.util.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon Jun 22 21:20:42 CEST 2015
  */
public class Parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\214\000\002\061\002\000\002\002\011\000\002\002" +
    "\004\000\002\041\003\000\002\003\004\000\002\003\002" +
    "\000\002\005\003\000\002\005\003\000\002\005\003\000" +
    "\002\006\006\000\002\006\005\000\002\011\005\000\002" +
    "\011\003\000\002\012\005\000\002\056\003\000\002\056" +
    "\003\000\002\056\003\000\002\056\003\000\002\013\004" +
    "\000\002\013\002\000\002\007\005\000\002\007\005\000" +
    "\002\007\005\000\002\014\005\000\002\014\003\000\002" +
    "\015\003\000\002\015\005\000\002\062\002\000\002\063" +
    "\002\000\002\010\012\000\002\016\004\000\002\016\005" +
    "\000\002\016\002\000\002\017\004\000\002\017\005\000" +
    "\002\017\002\000\002\020\003\000\002\020\003\000\002" +
    "\004\004\000\002\004\002\000\002\021\004\000\002\064" +
    "\002\000\002\021\005\000\002\065\002\000\002\066\002" +
    "\000\002\067\002\000\002\022\015\000\002\053\003\000" +
    "\002\053\002\000\002\054\005\000\002\054\003\000\002" +
    "\054\004\000\002\054\004\000\002\023\004\000\002\045" +
    "\003\000\002\025\004\000\002\025\002\000\002\032\003" +
    "\000\002\070\002\000\002\071\002\000\002\060\007\000" +
    "\002\024\003\000\002\024\003\000\002\027\005\000\002" +
    "\027\006\000\002\027\007\000\002\027\010\000\002\027" +
    "\004\000\002\072\002\000\002\030\004\000\002\030\007" +
    "\000\002\030\010\000\002\030\004\000\002\026\006\000" +
    "\002\026\006\000\002\026\006\000\002\026\005\000\002" +
    "\026\005\000\002\073\002\000\002\026\005\000\002\026" +
    "\007\000\002\026\007\000\002\026\011\000\002\026\004" +
    "\000\002\026\004\000\002\026\005\000\002\026\005\000" +
    "\002\026\011\000\002\026\007\000\002\026\003\000\002" +
    "\031\004\000\002\031\005\000\002\055\005\000\002\055" +
    "\003\000\002\055\005\000\002\055\005\000\002\074\002" +
    "\000\002\040\006\000\002\040\003\000\002\075\002\000" +
    "\002\037\006\000\002\037\003\000\002\036\005\000\002" +
    "\036\003\000\002\046\004\000\002\046\003\000\002\047" +
    "\005\000\002\047\003\000\002\050\005\000\002\050\003" +
    "\000\002\051\003\000\002\051\005\000\002\051\004\000" +
    "\002\051\007\000\002\051\003\000\002\051\003\000\002" +
    "\076\002\000\002\052\005\000\002\057\004\000\002\057" +
    "\005\000\002\042\003\000\002\077\002\000\002\042\005" +
    "\000\002\043\004\000\002\043\003\000\002\100\002\000" +
    "\002\044\006\000\002\044\005\000\002\044\004\000\002" +
    "\033\003\000\002\033\003\000\002\033\003\000\002\033" +
    "\003\000\002\033\003\000\002\033\003\000\002\034\003" +
    "\000\002\034\003\000\002\035\003\000\002\035\003\000" +
    "\002\035\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\363\000\004\004\005\001\002\000\004\002\365\001" +
    "\002\000\004\060\006\001\002\000\012\010\ufffe\021\ufffe" +
    "\046\ufffe\060\ufffe\001\002\000\012\010\001\021\001\046" +
    "\001\060\001\001\002\000\012\010\ufffc\021\ufffc\046\ufffc" +
    "\060\ufffc\001\002\000\012\010\020\021\022\046\013\060" +
    "\014\001\002\000\006\003\341\060\351\001\002\000\010" +
    "\007\056\047\uffda\060\014\001\002\000\052\003\uffcb\022" +
    "\uffcb\023\uffcb\026\uffcb\027\uffcb\030\uffcb\031\uffcb\032\uffcb" +
    "\033\uffcb\034\uffcb\035\uffcb\037\uffcb\040\uffcb\041\uffcb\042" +
    "\uffcb\043\uffcb\045\uffcb\050\uffcb\051\uffcb\060\uffcb\001\002" +
    "\000\012\010\ufffa\021\ufffa\046\ufffa\060\ufffa\001\002\000" +
    "\012\010\ufff9\021\ufff9\046\ufff9\060\ufff9\001\002\000\012" +
    "\010\ufffb\021\ufffb\046\ufffb\060\ufffb\001\002\000\004\060" +
    "\042\001\002\000\012\010\ufffd\021\ufffd\046\ufffd\060\ufffd" +
    "\001\002\000\006\003\024\060\014\001\002\000\004\060" +
    "\026\001\002\000\004\042\025\001\002\000\012\010\ufff7" +
    "\021\ufff7\046\ufff7\060\ufff7\001\002\000\004\036\034\001" +
    "\002\000\006\042\ufff5\043\ufff5\001\002\000\006\042\032" +
    "\043\031\001\002\000\004\060\026\001\002\000\012\010" +
    "\ufff8\021\ufff8\046\ufff8\060\ufff8\001\002\000\006\042\ufff6" +
    "\043\ufff6\001\002\000\012\053\036\054\040\055\037\056" +
    "\041\001\002\000\006\042\ufff4\043\ufff4\001\002\000\046" +
    "\003\ufff3\022\ufff3\023\ufff3\026\ufff3\027\ufff3\030\ufff3\031" +
    "\ufff3\032\ufff3\033\ufff3\034\ufff3\035\ufff3\037\ufff3\040\ufff3" +
    "\041\ufff3\042\ufff3\043\ufff3\045\ufff3\050\ufff3\001\002\000" +
    "\046\003\ufff1\022\ufff1\023\ufff1\026\ufff1\027\ufff1\030\ufff1" +
    "\031\ufff1\032\ufff1\033\ufff1\034\ufff1\035\ufff1\037\ufff1\040" +
    "\ufff1\041\ufff1\042\ufff1\043\ufff1\045\ufff1\050\ufff1\001\002" +
    "\000\046\003\ufff2\022\ufff2\023\ufff2\026\ufff2\027\ufff2\030" +
    "\ufff2\031\ufff2\032\ufff2\033\ufff2\034\ufff2\035\ufff2\037\ufff2" +
    "\040\ufff2\041\ufff2\042\ufff2\043\ufff2\045\ufff2\050\ufff2\001" +
    "\002\000\046\003\ufff0\022\ufff0\023\ufff0\026\ufff0\027\ufff0" +
    "\030\ufff0\031\ufff0\032\ufff0\033\ufff0\034\ufff0\035\ufff0\037" +
    "\ufff0\040\ufff0\041\ufff0\042\ufff0\043\ufff0\045\ufff0\050\ufff0" +
    "\001\002\000\006\011\uffe6\046\uffe6\001\002\000\006\011" +
    "\044\046\uffe1\001\002\000\006\003\355\060\356\001\002" +
    "\000\004\046\046\001\002\000\012\003\uffe5\007\uffe5\047" +
    "\uffe5\060\uffe5\001\002\000\012\003\051\007\056\047\uffde" +
    "\060\014\001\002\000\006\003\341\060\343\001\002\000" +
    "\012\003\051\007\056\047\uffde\060\014\001\002\000\012" +
    "\003\uffdd\007\uffdd\047\uffdd\060\uffdd\001\002\000\012\003" +
    "\051\007\056\047\uffde\060\014\001\002\000\012\003\uffdc" +
    "\007\uffdc\047\uffdc\060\uffdc\001\002\000\004\047\334\001" +
    "\002\000\004\060\uffd8\001\002\000\004\060\061\001\002" +
    "\000\012\003\uffd7\007\uffd7\047\uffd7\060\uffd7\001\002\000" +
    "\004\044\uffd6\001\002\000\004\044\063\001\002\000\010" +
    "\003\uffd5\045\uffd5\060\uffd5\001\002\000\010\003\067\045" +
    "\uffd1\060\014\001\002\000\004\045\uffd2\001\002\000\004" +
    "\060\333\001\002\000\006\043\331\045\332\001\002\000" +
    "\004\045\074\001\002\000\006\043\072\045\uffcf\001\002" +
    "\000\006\003\067\060\014\001\002\000\004\045\uffd0\001" +
    "\002\000\006\046\uffee\060\014\001\002\000\004\046\100" +
    "\001\002\000\006\046\uffee\060\014\001\002\000\004\046" +
    "\uffef\001\002\000\032\003\uffd4\005\uffd4\006\uffd4\013\uffd4" +
    "\015\uffd4\016\uffd4\017\uffd4\020\uffd4\042\uffd4\046\uffd4\047" +
    "\uffd4\060\uffd4\001\002\000\032\003\uffc9\005\uffc9\006\uffc9" +
    "\013\uffc9\015\uffc9\016\uffc9\017\uffc9\020\uffc9\042\uffc9\046" +
    "\uffc9\047\uffc9\060\uffc9\001\002\000\032\003\uffbd\005\uffbd" +
    "\006\uffbd\013\112\015\111\016\uffbd\017\uffbd\020\uffbd\042" +
    "\uffbd\046\uffbd\047\110\060\uffbd\001\002\000\032\003\uffc3" +
    "\005\uffc3\006\uffc3\013\uffc3\015\uffc3\016\uffc3\017\uffc3\020" +
    "\uffc3\042\uffc3\046\uffc3\047\uffc3\060\uffc3\001\002\000\032" +
    "\003\uffca\005\uffca\006\uffca\013\uffca\015\uffca\016\uffca\017" +
    "\uffca\020\uffca\042\uffca\046\uffca\047\uffca\060\uffca\001\002" +
    "\000\030\003\uffbd\005\uffbd\006\uffbd\013\112\015\111\016" +
    "\uffbd\017\uffbd\020\uffbd\042\uffbd\046\uffbd\060\uffbd\001\002" +
    "\000\024\003\252\005\253\006\254\016\244\017\256\020" +
    "\255\042\247\046\245\060\122\001\002\000\032\003\uffc4" +
    "\005\uffc4\006\uffc4\013\uffc4\015\uffc4\016\uffc4\017\uffc4\020" +
    "\uffc4\042\uffc4\046\uffc4\047\uffc4\060\uffc4\001\002\000\012" +
    "\003\uffd3\007\uffd3\047\uffd3\060\uffd3\001\002\000\006\003" +
    "\241\044\115\001\002\000\006\003\113\044\115\001\002" +
    "\000\004\045\233\001\002\000\030\003\uffbd\005\uffbd\006" +
    "\uffbd\013\112\015\111\016\uffbd\017\uffbd\020\uffbd\042\uffbd" +
    "\046\uffbd\060\uffbd\001\002\000\022\012\uffc7\035\uffc7\044" +
    "\uffc7\053\uffc7\054\uffc7\055\uffc7\056\uffc7\060\uffc7\001\002" +
    "\000\022\012\130\035\126\044\125\053\036\054\040\055" +
    "\037\056\041\060\122\001\002\000\050\003\uff8f\022\uff8f" +
    "\023\uff8f\026\uff8f\027\uff8f\030\uff8f\031\uff8f\032\uff8f\033" +
    "\uff8f\034\uff8f\035\uff8f\037\uff8f\040\uff8f\041\uff8f\042\uff8f" +
    "\043\uff8f\044\uff8d\045\uff8f\050\uff8f\001\002\000\040\003" +
    "\uff98\022\uff98\023\uff98\026\uff98\027\uff98\030\uff98\031\uff98" +
    "\032\uff98\033\uff98\034\154\035\155\042\uff98\043\uff98\045" +
    "\uff98\050\uff98\001\002\000\046\003\uff94\022\uff94\023\uff94" +
    "\026\uff94\027\uff94\030\uff94\031\uff94\032\uff94\033\uff94\034" +
    "\uff94\035\uff94\037\uff94\040\uff94\041\uff94\042\uff94\043\uff94" +
    "\045\uff94\050\uff94\001\002\000\062\003\uff89\022\uff89\023" +
    "\uff89\024\uff89\025\uff89\026\uff89\027\uff89\030\uff89\031\uff89" +
    "\032\uff89\033\uff89\034\uff89\035\uff89\036\uff89\037\uff89\040" +
    "\uff89\041\uff89\042\uff89\043\uff89\044\uff89\045\uff89\050\uff89" +
    "\051\uff88\052\uff88\001\002\000\010\022\uff9c\023\uff9e\045" +
    "\uff9c\001\002\000\024\022\uff9a\023\uff9a\026\166\027\162" +
    "\030\165\031\164\032\167\033\163\045\uff9a\001\002\000" +
    "\022\012\130\035\126\044\125\053\036\054\040\055\037" +
    "\056\041\060\122\001\002\000\020\012\130\044\125\053" +
    "\036\054\040\055\037\056\041\060\122\001\002\000\046" +
    "\003\uff8e\022\uff8e\023\uff8e\026\uff8e\027\uff8e\030\uff8e\031" +
    "\uff8e\032\uff8e\033\uff8e\034\uff8e\035\uff8e\037\uff8e\040\uff8e" +
    "\041\uff8e\042\uff8e\043\uff8e\045\uff8e\050\uff8e\001\002\000" +
    "\004\060\014\001\002\000\006\022\uffa1\045\uff9f\001\002" +
    "\000\046\003\uff96\022\uff96\023\uff96\026\uff96\027\uff96\030" +
    "\uff96\031\uff96\032\uff96\033\uff96\034\uff96\035\uff96\037\142" +
    "\040\140\041\137\042\uff96\043\uff96\045\uff96\050\uff96\001" +
    "\002\000\004\045\uffc6\001\002\000\046\003\uff93\022\uff93" +
    "\023\uff93\026\uff93\027\uff93\030\uff93\031\uff93\032\uff93\033" +
    "\uff93\034\uff93\035\uff93\037\uff93\040\uff93\041\uff93\042\uff93" +
    "\043\uff93\045\uff93\050\uff93\001\002\000\004\045\136\001" +
    "\002\000\030\003\uffc5\005\uffc5\006\uffc5\013\uffc5\015\uffc5" +
    "\016\uffc5\017\uffc5\020\uffc5\042\uffc5\046\uffc5\060\uffc5\001" +
    "\002\000\020\012\uff76\044\uff76\053\uff76\054\uff76\055\uff76" +
    "\056\uff76\060\uff76\001\002\000\020\012\uff77\044\uff77\053" +
    "\uff77\054\uff77\055\uff77\056\uff77\060\uff77\001\002\000\020" +
    "\012\130\044\125\053\036\054\040\055\037\056\041\060" +
    "\122\001\002\000\020\012\uff78\044\uff78\053\uff78\054\uff78" +
    "\055\uff78\056\uff78\060\uff78\001\002\000\046\003\uff95\022" +
    "\uff95\023\uff95\026\uff95\027\uff95\030\uff95\031\uff95\032\uff95" +
    "\033\uff95\034\uff95\035\uff95\037\uff95\040\uff95\041\uff95\042" +
    "\uff95\043\uff95\045\uff95\050\uff95\001\002\000\004\022\145" +
    "\001\002\000\022\012\130\035\126\044\125\053\036\054" +
    "\040\055\037\056\041\060\122\001\002\000\004\045\uffa0" +
    "\001\002\000\050\003\uff91\022\uff91\023\uff91\026\uff91\027" +
    "\uff91\030\uff91\031\uff91\032\uff91\033\uff91\034\uff91\035\uff91" +
    "\037\uff91\040\uff91\041\uff91\042\uff91\043\uff91\045\uff91\050" +
    "\uff91\051\150\001\002\000\022\012\130\035\126\044\125" +
    "\053\036\054\040\055\037\056\041\060\122\001\002\000" +
    "\004\050\152\001\002\000\046\003\uff90\022\uff90\023\uff90" +
    "\026\uff90\027\uff90\030\uff90\031\uff90\032\uff90\033\uff90\034" +
    "\uff90\035\uff90\037\uff90\040\uff90\041\uff90\042\uff90\043\uff90" +
    "\045\uff90\050\uff90\001\002\000\040\003\uff99\022\uff99\023" +
    "\uff99\026\uff99\027\uff99\030\uff99\031\uff99\032\uff99\033\uff99" +
    "\034\154\035\155\042\uff99\043\uff99\045\uff99\050\uff99\001" +
    "\002\000\020\012\uff7a\044\uff7a\053\uff7a\054\uff7a\055\uff7a" +
    "\056\uff7a\060\uff7a\001\002\000\020\012\uff79\044\uff79\053" +
    "\uff79\054\uff79\055\uff79\056\uff79\060\uff79\001\002\000\020" +
    "\012\130\044\125\053\036\054\040\055\037\056\041\060" +
    "\122\001\002\000\046\003\uff97\022\uff97\023\uff97\026\uff97" +
    "\027\uff97\030\uff97\031\uff97\032\uff97\033\uff97\034\uff97\035" +
    "\uff97\037\142\040\140\041\137\042\uff97\043\uff97\045\uff97" +
    "\050\uff97\001\002\000\004\045\161\001\002\000\046\003" +
    "\uff92\022\uff92\023\uff92\026\uff92\027\uff92\030\uff92\031\uff92" +
    "\032\uff92\033\uff92\034\uff92\035\uff92\037\uff92\040\uff92\041" +
    "\uff92\042\uff92\043\uff92\045\uff92\050\uff92\001\002\000\022" +
    "\012\uff7f\035\uff7f\044\uff7f\053\uff7f\054\uff7f\055\uff7f\056" +
    "\uff7f\060\uff7f\001\002\000\022\012\uff7b\035\uff7b\044\uff7b" +
    "\053\uff7b\054\uff7b\055\uff7b\056\uff7b\060\uff7b\001\002\000" +
    "\022\012\uff7d\035\uff7d\044\uff7d\053\uff7d\054\uff7d\055\uff7d" +
    "\056\uff7d\060\uff7d\001\002\000\022\012\uff7e\035\uff7e\044" +
    "\uff7e\053\uff7e\054\uff7e\055\uff7e\056\uff7e\060\uff7e\001\002" +
    "\000\022\012\uff80\035\uff80\044\uff80\053\uff80\054\uff80\055" +
    "\uff80\056\uff80\060\uff80\001\002\000\022\012\uff7c\035\uff7c" +
    "\044\uff7c\053\uff7c\054\uff7c\055\uff7c\056\uff7c\060\uff7c\001" +
    "\002\000\022\012\130\035\126\044\125\053\036\054\040" +
    "\055\037\056\041\060\122\001\002\000\010\022\uff9b\023" +
    "\uff9b\045\uff9b\001\002\000\004\023\173\001\002\000\022" +
    "\012\130\035\126\044\125\053\036\054\040\055\037\056" +
    "\041\060\122\001\002\000\006\022\uff9d\045\uff9d\001\002" +
    "\000\006\051\200\052\201\001\002\000\062\003\uff85\022" +
    "\uff85\023\uff85\024\uff85\025\uff85\026\uff85\027\uff85\030\uff85" +
    "\031\uff85\032\uff85\033\uff85\034\uff85\035\uff85\036\uff85\037" +
    "\uff85\040\uff85\041\uff85\042\uff85\043\uff85\044\uff85\045\uff85" +
    "\050\uff85\051\uff85\052\uff85\001\002\000\062\003\uff87\022" +
    "\uff87\023\uff87\024\uff87\025\uff87\026\uff87\027\uff87\030\uff87" +
    "\031\uff87\032\uff87\033\uff87\034\uff87\035\uff87\036\uff87\037" +
    "\uff87\040\uff87\041\uff87\042\uff87\043\uff87\044\uff87\045\uff87" +
    "\050\uff87\051\200\052\201\001\002\000\024\003\203\012" +
    "\uff84\035\uff84\044\uff84\053\uff84\054\uff84\055\uff84\056\uff84" +
    "\060\uff84\001\002\000\004\060\202\001\002\000\062\003" +
    "\uff81\022\uff81\023\uff81\024\uff81\025\uff81\026\uff81\027\uff81" +
    "\030\uff81\031\uff81\032\uff81\033\uff81\034\uff81\035\uff81\036" +
    "\uff81\037\uff81\040\uff81\041\uff81\042\uff81\043\uff81\044\uff81" +
    "\045\uff81\050\uff81\051\uff81\052\uff81\001\002\000\004\050" +
    "\207\001\002\000\022\012\130\035\126\044\125\053\036" +
    "\054\040\055\037\056\041\060\122\001\002\000\004\050" +
    "\206\001\002\000\062\003\uff83\022\uff83\023\uff83\024\uff83" +
    "\025\uff83\026\uff83\027\uff83\030\uff83\031\uff83\032\uff83\033" +
    "\uff83\034\uff83\035\uff83\036\uff83\037\uff83\040\uff83\041\uff83" +
    "\042\uff83\043\uff83\044\uff83\045\uff83\050\uff83\051\uff83\052" +
    "\uff83\001\002\000\062\003\uff82\022\uff82\023\uff82\024\uff82" +
    "\025\uff82\026\uff82\027\uff82\030\uff82\031\uff82\032\uff82\033" +
    "\uff82\034\uff82\035\uff82\036\uff82\037\uff82\040\uff82\041\uff82" +
    "\042\uff82\043\uff82\044\uff82\045\uff82\050\uff82\051\uff82\052" +
    "\uff82\001\002\000\062\003\uff86\022\uff86\023\uff86\024\uff86" +
    "\025\uff86\026\uff86\027\uff86\030\uff86\031\uff86\032\uff86\033" +
    "\uff86\034\uff86\035\uff86\036\uff86\037\uff86\040\uff86\041\uff86" +
    "\042\uff86\043\uff86\044\uff86\045\uff86\050\uff86\051\uff86\052" +
    "\uff86\001\002\000\004\044\213\001\002\000\046\003\uff8c" +
    "\022\uff8c\023\uff8c\026\uff8c\027\uff8c\030\uff8c\031\uff8c\032" +
    "\uff8c\033\uff8c\034\uff8c\035\uff8c\037\uff8c\040\uff8c\041\uff8c" +
    "\042\uff8c\043\uff8c\045\uff8c\050\uff8c\001\002\000\024\012" +
    "\130\035\126\044\125\045\216\053\036\054\040\055\037" +
    "\056\041\060\122\001\002\000\010\003\uffa4\043\uffa4\045" +
    "\uffa4\001\002\000\010\003\221\043\217\045\220\001\002" +
    "\000\046\003\uff8b\022\uff8b\023\uff8b\026\uff8b\027\uff8b\030" +
    "\uff8b\031\uff8b\032\uff8b\033\uff8b\034\uff8b\035\uff8b\037\uff8b" +
    "\040\uff8b\041\uff8b\042\uff8b\043\uff8b\045\uff8b\050\uff8b\001" +
    "\002\000\022\012\130\035\126\044\125\053\036\054\040" +
    "\055\037\056\041\060\122\001\002\000\046\003\uff8a\022" +
    "\uff8a\023\uff8a\026\uff8a\027\uff8a\030\uff8a\031\uff8a\032\uff8a" +
    "\033\uff8a\034\uff8a\035\uff8a\037\uff8a\040\uff8a\041\uff8a\042" +
    "\uff8a\043\uff8a\045\uff8a\050\uff8a\001\002\000\006\043\222" +
    "\045\223\001\002\000\010\003\uffa3\043\uffa3\045\uffa3\001" +
    "\002\000\010\003\uffa2\043\uffa2\045\uffa2\001\002\000\010" +
    "\003\uffa5\043\uffa5\045\uffa5\001\002\000\034\003\uffc3\005" +
    "\uffc3\006\uffc3\013\uffc3\014\227\015\uffc3\016\uffc3\017\uffc3" +
    "\020\uffc3\042\uffc3\046\uffc3\047\uffc3\060\uffc3\001\002\000" +
    "\032\003\uffc2\005\uffc2\006\uffc2\013\uffc2\015\uffc2\016\uffc2" +
    "\017\uffc2\020\uffc2\042\uffc2\046\uffc2\047\uffc2\060\uffc2\001" +
    "\002\000\030\003\uffc8\005\uffc8\006\uffc8\013\uffc8\015\uffc8" +
    "\016\uffc8\017\uffc8\020\uffc8\042\uffc8\046\uffc8\060\uffc8\001" +
    "\002\000\030\003\uffbd\005\uffbd\006\uffbd\013\112\015\111" +
    "\016\uffbd\017\uffbd\020\uffbd\042\uffbd\046\uffbd\060\uffbd\001" +
    "\002\000\034\003\uffbb\005\uffbb\006\uffbb\013\uffbb\014\uffbb" +
    "\015\uffbb\016\uffbb\017\uffbb\020\uffbb\042\uffbb\046\uffbb\047" +
    "\uffbb\060\uffbb\001\002\000\032\003\uffc0\005\uffc0\006\uffc0" +
    "\013\uffc0\015\uffc0\016\uffc0\017\uffc0\020\uffc0\042\uffc0\046" +
    "\uffc0\047\uffc0\060\uffc0\001\002\000\030\003\uffbd\005\uffbd" +
    "\006\uffbd\013\112\015\111\016\uffbd\017\uffbd\020\uffbd\042" +
    "\uffbd\046\uffbd\060\uffbd\001\002\000\034\003\uffc3\005\uffc3" +
    "\006\uffc3\013\uffc3\014\236\015\uffc3\016\uffc3\017\uffc3\020" +
    "\uffc3\042\uffc3\046\uffc3\047\uffc3\060\uffc3\001\002\000\032" +
    "\003\uffc1\005\uffc1\006\uffc1\013\uffc1\015\uffc1\016\uffc1\017" +
    "\uffc1\020\uffc1\042\uffc1\046\uffc1\047\uffc1\060\uffc1\001\002" +
    "\000\030\003\uffbd\005\uffbd\006\uffbd\013\112\015\111\016" +
    "\uffbd\017\uffbd\020\uffbd\042\uffbd\046\uffbd\060\uffbd\001\002" +
    "\000\034\003\uffba\005\uffba\006\uffba\013\uffba\014\uffba\015" +
    "\uffba\016\uffba\017\uffba\020\uffba\042\uffba\046\uffba\047\uffba" +
    "\060\uffba\001\002\000\032\003\uffbf\005\uffbf\006\uffbf\013" +
    "\uffbf\015\uffbf\016\uffbf\017\uffbf\020\uffbf\042\uffbf\046\uffbf" +
    "\047\uffbf\060\uffbf\001\002\000\004\045\243\001\002\000" +
    "\030\003\uffa7\005\uffa7\006\uffa7\013\uffa7\015\uffa7\016\uffa7" +
    "\017\uffa7\020\uffa7\042\uffa7\046\uffa7\060\uffa7\001\002\000" +
    "\030\003\uffa6\005\uffa6\006\uffa6\013\uffa6\015\uffa6\016\uffa6" +
    "\017\uffa6\020\uffa6\042\uffa6\046\uffa6\060\uffa6\001\002\000" +
    "\004\044\323\001\002\000\032\003\uffc9\005\uffc9\006\uffc9" +
    "\013\uffc9\015\uffc9\016\uffc9\017\uffc9\020\uffc9\042\uffc9\046" +
    "\uffc9\047\uffc9\060\uffc9\001\002\000\012\024\312\025\310" +
    "\036\311\044\uff8d\001\002\000\034\003\uffa8\005\uffa8\006" +
    "\uffa8\013\uffa8\014\uffa8\015\uffa8\016\uffa8\017\uffa8\020\uffa8" +
    "\042\uffa8\046\uffa8\047\uffa8\060\uffa8\001\002\000\034\003" +
    "\uffbc\005\uffbc\006\uffbc\013\uffbc\014\uffbc\015\uffbc\016\uffbc" +
    "\017\uffbc\020\uffbc\042\uffbc\046\uffbc\047\uffbc\060\uffbc\001" +
    "\002\000\004\042\uffb3\001\002\000\004\036\303\001\002" +
    "\000\004\044\273\001\002\000\024\012\130\035\126\042" +
    "\271\044\125\053\036\054\040\055\037\056\041\060\122" +
    "\001\002\000\030\003\uffbd\005\uffbd\006\uffbd\013\112\015" +
    "\111\016\uffbd\017\uffbd\020\uffbd\042\uffbd\046\uffbd\060\uffbd" +
    "\001\002\000\004\042\257\001\002\000\034\003\uffae\005" +
    "\uffae\006\uffae\013\uffae\014\uffae\015\uffae\016\uffae\017\uffae" +
    "\020\uffae\042\uffae\046\uffae\047\uffae\060\uffae\001\002\000" +
    "\004\015\261\001\002\000\006\003\262\044\263\001\002" +
    "\000\004\045\267\001\002\000\022\012\130\035\126\044" +
    "\125\053\036\054\040\055\037\056\041\060\122\001\002" +
    "\000\004\045\265\001\002\000\004\042\266\001\002\000" +
    "\034\003\uffaa\005\uffaa\006\uffaa\013\uffaa\014\uffaa\015\uffaa" +
    "\016\uffaa\017\uffaa\020\uffaa\042\uffaa\046\uffaa\047\uffaa\060" +
    "\uffaa\001\002\000\034\003\uffa9\005\uffa9\006\uffa9\013\uffa9" +
    "\014\uffa9\015\uffa9\016\uffa9\017\uffa9\020\uffa9\042\uffa9\046" +
    "\uffa9\047\uffa9\060\uffa9\001\002\000\004\042\272\001\002" +
    "\000\034\003\uffad\005\uffad\006\uffad\013\uffad\014\uffad\015" +
    "\uffad\016\uffad\017\uffad\020\uffad\042\uffad\046\uffad\047\uffad" +
    "\060\uffad\001\002\000\034\003\uffac\005\uffac\006\uffac\013" +
    "\uffac\014\uffac\015\uffac\016\uffac\017\uffac\020\uffac\042\uffac" +
    "\046\uffac\047\uffac\060\uffac\001\002\000\022\012\130\035" +
    "\126\044\125\053\036\054\040\055\037\056\041\060\122" +
    "\001\002\000\006\043\275\045\276\001\002\000\004\053" +
    "\300\001\002\000\004\042\277\001\002\000\034\003\uffb0" +
    "\005\uffb0\006\uffb0\013\uffb0\014\uffb0\015\uffb0\016\uffb0\017" +
    "\uffb0\020\uffb0\042\uffb0\046\uffb0\047\uffb0\060\uffb0\001\002" +
    "\000\004\045\301\001\002\000\004\042\302\001\002\000" +
    "\034\003\uffaf\005\uffaf\006\uffaf\013\uffaf\014\uffaf\015\uffaf" +
    "\016\uffaf\017\uffaf\020\uffaf\042\uffaf\046\uffaf\047\uffaf\060" +
    "\uffaf\001\002\000\022\012\130\035\126\044\125\053\036" +
    "\054\040\055\037\056\041\060\122\001\002\000\004\042" +
    "\305\001\002\000\034\003\uffb6\005\uffb6\006\uffb6\013\uffb6" +
    "\014\uffb6\015\uffb6\016\uffb6\017\uffb6\020\uffb6\042\uffb6\046" +
    "\uffb6\047\uffb6\060\uffb6\001\002\000\004\042\307\001\002" +
    "\000\034\003\uffb2\005\uffb2\006\uffb2\013\uffb2\014\uffb2\015" +
    "\uffb2\016\uffb2\017\uffb2\020\uffb2\042\uffb2\046\uffb2\047\uffb2" +
    "\060\uffb2\001\002\000\004\042\320\001\002\000\024\003" +
    "\315\012\130\035\126\044\125\053\036\054\040\055\037" +
    "\056\041\060\122\001\002\000\004\042\313\001\002\000" +
    "\034\003\uffb5\005\uffb5\006\uffb5\013\uffb5\014\uffb5\015\uffb5" +
    "\016\uffb5\017\uffb5\020\uffb5\042\uffb5\046\uffb5\047\uffb5\060" +
    "\uffb5\001\002\000\004\042\317\001\002\000\004\042\316" +
    "\001\002\000\034\003\uffb7\005\uffb7\006\uffb7\013\uffb7\014" +
    "\uffb7\015\uffb7\016\uffb7\017\uffb7\020\uffb7\042\uffb7\046\uffb7" +
    "\047\uffb7\060\uffb7\001\002\000\034\003\uffb8\005\uffb8\006" +
    "\uffb8\013\uffb8\014\uffb8\015\uffb8\016\uffb8\017\uffb8\020\uffb8" +
    "\042\uffb8\046\uffb8\047\uffb8\060\uffb8\001\002\000\034\003" +
    "\uffb4\005\uffb4\006\uffb4\013\uffb4\014\uffb4\015\uffb4\016\uffb4" +
    "\017\uffb4\020\uffb4\042\uffb4\046\uffb4\047\uffb4\060\uffb4\001" +
    "\002\000\032\003\uffbd\005\uffbd\006\uffbd\013\112\015\111" +
    "\016\uffbd\017\uffbd\020\uffbd\042\uffbd\046\uffbd\047\322\060" +
    "\uffbd\001\002\000\034\003\uffab\005\uffab\006\uffab\013\uffab" +
    "\014\uffab\015\uffab\016\uffab\017\uffab\020\uffab\042\uffab\046" +
    "\uffab\047\uffab\060\uffab\001\002\000\004\060\122\001\002" +
    "\000\004\045\325\001\002\000\004\042\326\001\002\000" +
    "\034\003\uffb1\005\uffb1\006\uffb1\013\uffb1\014\uffb1\015\uffb1" +
    "\016\uffb1\017\uffb1\020\uffb1\042\uffb1\046\uffb1\047\uffb1\060" +
    "\uffb1\001\002\000\034\003\uffb9\005\uffb9\006\uffb9\013\uffb9" +
    "\014\uffb9\015\uffb9\016\uffb9\017\uffb9\020\uffb9\042\uffb9\046" +
    "\uffb9\047\uffb9\060\uffb9\001\002\000\032\003\uffbe\005\uffbe" +
    "\006\uffbe\013\uffbe\015\uffbe\016\uffbe\017\uffbe\020\uffbe\042" +
    "\uffbe\046\uffbe\047\uffbe\060\uffbe\001\002\000\004\045\uffce" +
    "\001\002\000\004\045\uffcd\001\002\000\006\043\uffcc\045" +
    "\uffcc\001\002\000\012\010\uffe4\021\uffe4\046\uffe4\060\uffe4" +
    "\001\002\000\004\047\uffe0\001\002\000\004\047\337\001" +
    "\002\000\004\047\uffdf\001\002\000\012\003\uffd9\007\uffd9" +
    "\047\uffd9\060\uffd9\001\002\000\006\042\354\046\353\001" +
    "\002\000\006\042\350\043\347\001\002\000\012\042\uffe8" +
    "\043\uffe8\044\uffd6\051\345\001\002\000\006\042\uffe9\043" +
    "\uffe9\001\002\000\004\050\346\001\002\000\006\042\uffe7" +
    "\043\uffe7\001\002\000\004\060\351\001\002\000\020\003" +
    "\uffed\007\uffed\010\uffed\021\uffed\046\uffed\047\uffed\060\uffed" +
    "\001\002\000\010\042\uffe8\043\uffe8\051\345\001\002\000" +
    "\006\042\uffea\043\uffea\001\002\000\020\003\uffeb\007\uffeb" +
    "\010\uffeb\021\uffeb\046\uffeb\047\uffeb\060\uffeb\001\002\000" +
    "\020\003\uffec\007\uffec\010\uffec\021\uffec\046\uffec\047\uffec" +
    "\060\uffec\001\002\000\004\046\357\001\002\000\004\046" +
    "\uffe3\001\002\000\004\046\uffe2\001\002\000\004\060\061" +
    "\001\002\000\004\047\364\001\002\000\010\007\056\047" +
    "\uffda\060\014\001\002\000\004\047\uffdb\001\002\000\004" +
    "\002\000\001\002\000\004\002\uffff\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\363\000\004\002\003\001\001\000\002\001\001\000" +
    "\004\041\006\001\001\000\002\001\001\000\004\061\007" +
    "\001\001\000\004\003\010\001\001\000\014\005\020\006" +
    "\016\007\014\010\015\045\011\001\001\000\006\014\341" +
    "\015\343\001\001\000\010\004\360\021\361\045\357\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\045\022\001\001\000\006\011\027\012\026\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\012\032\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\056\034\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\062\042\001" +
    "\001\000\004\016\044\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\063\046\001\001\000\014\007\051\017" +
    "\054\020\052\021\053\045\047\001\001\000\010\014\341" +
    "\015\343\022\337\001\001\000\014\007\051\017\335\020" +
    "\052\021\053\045\047\001\001\000\002\001\001\000\014" +
    "\007\051\017\334\020\052\021\053\045\047\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\064\056\001\001" +
    "\000\004\022\057\001\001\000\002\001\001\000\004\065" +
    "\061\001\001\000\002\001\001\000\004\066\063\001\001" +
    "\000\012\023\070\045\065\053\067\054\064\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\023\070\045\065\054" +
    "\072\001\001\000\002\001\001\000\010\007\075\013\074" +
    "\045\011\001\001\000\002\001\001\000\010\007\075\013" +
    "\076\045\011\001\001\000\002\001\001\000\004\067\100" +
    "\001\001\000\004\025\101\001\001\000\014\024\103\027" +
    "\106\030\102\031\104\072\105\001\001\000\002\001\001" +
    "\000\002\001\001\000\012\027\327\030\326\031\104\072" +
    "\105\001\001\000\010\026\247\042\245\052\250\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\060\241\001" +
    "\001\000\004\060\113\001\001\000\002\001\001\000\014" +
    "\024\225\027\106\030\224\031\104\072\105\001\001\000" +
    "\004\070\115\001\001\000\026\036\122\037\130\040\132" +
    "\042\116\046\123\047\117\050\131\051\120\052\126\056" +
    "\133\001\001\000\004\076\210\001\001\000\004\034\155" +
    "\001\001\000\002\001\001\000\004\077\174\001\001\000" +
    "\004\075\171\001\001\000\004\033\167\001\001\000\020" +
    "\042\116\046\157\047\117\050\131\051\120\052\126\056" +
    "\133\001\001\000\016\042\116\047\152\050\131\051\120" +
    "\052\126\056\133\001\001\000\002\001\001\000\004\045" +
    "\146\001\001\000\004\074\143\001\001\000\004\035\140" +
    "\001\001\000\004\071\134\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\012\042\116\051\142\052\126\056\133\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\026\036\122\037\130\040\145\042\116\046\123\047" +
    "\117\050\131\051\120\052\126\056\133\001\001\000\002" +
    "\001\001\000\002\001\001\000\020\042\116\046\150\047" +
    "\117\050\131\051\120\052\126\056\133\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\034\155\001\001\000" +
    "\002\001\001\000\002\001\001\000\014\042\116\050\156" +
    "\051\120\052\126\056\133\001\001\000\004\035\140\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\020\042\116\046\170" +
    "\047\117\050\131\051\120\052\126\056\133\001\001\000" +
    "\002\001\001\000\002\001\001\000\024\036\122\037\173" +
    "\042\116\046\123\047\117\050\131\051\120\052\126\056" +
    "\133\001\001\000\002\001\001\000\006\043\176\044\175" +
    "\001\001\000\002\001\001\000\004\044\207\001\001\000" +
    "\004\100\203\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\020\042\116\046\204\047\117\050" +
    "\131\051\120\052\126\056\133\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\057\211\001\001\000\002\001\001\000\022\042\116" +
    "\046\213\047\117\050\131\051\120\052\126\055\214\056" +
    "\133\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\020\042\116\046\223\047\117\050\131\051" +
    "\120\052\126\056\133\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\032\227\001\001\000\002\001\001\000\002" +
    "\001\001\000\012\027\231\030\230\031\104\072\105\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\024\234" +
    "\027\106\030\233\031\104\072\105\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\027\237\030\236\031\104" +
    "\072\105\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\025\320\001\001\000\004\076\210\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\073\305" +
    "\001\001\000\002\001\001\000\002\001\001\000\020\042" +
    "\116\046\267\047\117\050\131\051\120\052\126\056\133" +
    "\001\001\000\014\024\257\027\106\030\102\031\104\072" +
    "\105\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\026\036" +
    "\122\037\130\040\263\042\116\046\123\047\117\050\131" +
    "\051\120\052\126\056\133\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\020\042" +
    "\116\046\273\047\117\050\131\051\120\052\126\056\133" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\020\042\116\046\303\047\117\050" +
    "\131\051\120\052\126\056\133\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\020\042\116\046\313\047\117\050\131" +
    "\051\120\052\126\056\133\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\024" +
    "\103\027\106\030\102\031\104\072\105\001\001\000\002" +
    "\001\001\000\004\042\323\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\065\061\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\015\351\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\022\337\001\001" +
    "\000\002\001\001\000\010\004\362\021\361\045\357\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 2;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	Tab.init();
	
	Tab.currentScope.addToLocals(new Obj(Obj.Type, "string", Parser.String));
	Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool", Parser.Bool));

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {

	Symbol symbol = this.getScanner().next_token();
	/*if(symbol != null && symbol.value != null){
		System.out.println(symbol.toString() + " " + symbol.value.toString());
	}*/
	if(symbol.sym == sym.INVALID){
		System.err.println("INVALID symbol");
		symbol = this.getScanner().next_token();
	}
	return symbol;

    }



	//level A
	int nDeclGlobSimpleVars;
	int nDeclGlobSimpleConsts;
	int nSimpleMainStatements;
	int nStatementBlocks;
	
	//level B
	int nDefProgramFuncs;
	int nDeclGlobArrays;
	int nFuncCallsInMain;
	
	//level C
	int nDeclClasses;
	int nDefClassMeths;
	int nObjInsts;
	
	//flags
	int inProgramParams; //if greater that zero, currently parsed elements are members of program - global scope
	boolean inMain; //if currently parsing main
	boolean errorDetected;
	
	public static Struct String = new Struct(Struct.Array, Tab.charType);
	public static Struct Bool = new Struct(Struct.Bool);
	
	public void dbg(Object o){
		System.out.println(o);
	}
	
	public void report_error(String message, Object info){
		StringBuilder builder = new StringBuilder(message);
		if(info instanceof Symbol){
			builder.append(" in line ").append(((Symbol)info).left);
		}
		System.err.println(builder.toString());
		errorDetected = true;
	}
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception{
		done_parsing();
		report_error(message, info);
		errorDetected = true;
	}
	
	public void report_semanthic_error(String message, Object info) throws java.lang.Exception {
		report_error(message, info);
	}

	public void syntax_error(Symbol cur_token){
		report_error("\nSyntax error", cur_token);
	}

	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception{
		report_fatal_error("\nFatal error!", cur_token);
	}

	public void report_info(String message, Object info){
		StringBuilder builder = new StringBuilder(message);
		if(info instanceof Symbol){
			builder.append(" in line ").append(((Symbol)info).left);
		}
		System.out.println(builder.toString());
	}


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$Parser$actions {



		class LiteralHolder {
			public Object value;
			public Struct type;
			public LiteralHolder(Object value, Struct type){
				this.value = value; this.type = type;
			}
		
			public int getIntValue(){
				if(type.getKind() == Struct.Int){
					return ((Integer)value).intValue();
				} else if (type.getKind() == Struct.Char) {
					return (int)((Character)value).charValue();
				} else if (type.getKind() == Struct.Bool) {
					return ((Boolean)value) ? 1 : 0 ;
				} else {
						try{
							parser.report_fatal_error("Literal has unknown type.",null);
						}catch(Exception ex){
							ex.printStackTrace();
						}
					return -1;
				}
			}
		}
		
		static class AdrDest {
			public int address;
			public int dest;
			public static int BEGIN = 1; //If
			public static int END = 2; //Else
			public static int NEXT = 3; //next term
			public AdrDest(int address, int dest){
				this.address = address;
				this.dest = dest;
			}
		}


		Struct currentType; //return type of method being parsed or type of consts or variables while parsing declaration
		int isVoid; // -1 not void, 0 undefined, 1 void
		Obj currentClass = Tab.noObj; //refers to class currently being parsed
		Obj currentMeth;			//refers to method/function currently being parsed
		Obj currentMethBeingCalled; //points to method that is being called while parsing ActPars
		boolean returnExists;
		int currentActPar;			//number of actual parameter currently being parsed, for matching purpose
		Obj currentDesignator;		//while parsing designator resolving expression, this poinst to this.inExpression or this[inExpression] ...
		Obj currentThis = Tab.noObj;//if designator resolvs in method that is part of class this points to that class
		Obj thisForMethCall = Tab.noObj; //resolvs to this argument of methods, can be equal to currentThis but there are situations when reference to class is implicit, then currentThis will be Tab.noObj, but thisForMethCall will point to right thing
		int currentLevel = -1; //current scope level => -1 = univers
		int ifAdr; //address of if statement for backpatching
		boolean lastTermInCondition;
		
		Deque<Deque<AdrDest>> condTerms;
		Deque<Integer> condTermAddresses;
		int beginIfAddress;
		
		void patchCondition(){
			condTermAddresses.addLast(Code.pc);
		
			Iterator<Integer> it = condTermAddresses.iterator();
			
			for(Deque<AdrDest> facts : condTerms){
				int nextAdr = it.next();
				
				for(AdrDest ad : facts){
					int patchAdr = ad.address;
					if(ad.dest == AdrDest.BEGIN){
						Code.put2(patchAdr, (beginIfAddress-patchAdr + 1));
					} else if (ad.dest == AdrDest.NEXT) {
						Code.put2(patchAdr, (nextAdr-patchAdr + 1));
					} else {
						parser.report_error("Nupus se!", null);
					}
				}
			}
		}
		
		
		String[] kinds = {"constant", "variable", "type", "method", "field", "element", "program"};
		Stack<Obj> currentDesignatorStack = new Stack<Obj>();
		Stack<Obj> currentThisStack = new Stack<Obj>();
		Stack<Obj> thisForMethCallStack = new Stack<Obj>();
		Stack<Obj> currentMethBeingCalledStack = new Stack<Obj>();
		
		void popCurrentThis(){
			currentThis = currentThisStack.pop();
		}
		
		void pushCurrentThis(){
			currentThisStack.push(currentThis);
			currentThis = Tab.noObj;
		}
		
		void pushCurrentDesignator() {
			currentDesignatorStack.push(currentDesignator);
			currentDesignator = Tab.noObj;
		}
		
		void popCurrentDesignator() {
			currentDesignator = currentDesignatorStack.pop();
		}
		
		void popThisForMethCallStack(){
			thisForMethCall = thisForMethCallStack.pop();
			currentMethBeingCalled = currentMethBeingCalledStack.pop();
		}
		
		void pushThisForMethCallStack(){
			thisForMethCallStack.push(thisForMethCall);
			thisForMethCall = Tab.noObj;
			currentMethBeingCalledStack.push(currentMethBeingCalled);
			currentMethBeingCalled = Tab.noObj;
		}
		
		
		void initCurrentThis(Obj local, int ileft) throws Exception {
			if(local.getKind() == Obj.Meth){
				if(currentDesignator.getType().getKind() == Struct.Class){
					currentThis = currentDesignator;
				} else {
					parser.report_semanthic_error(ileft + " : Method called for non-class type.",null);
					currentThis = Tab.noObj;
				}
			}else{
				currentThis = Tab.noObj;
			}

		}
		
		
		void doIncOrDec(Obj d, int op, int dleft) throws Exception {
		
			int diff = (op == Code.add) ? 1 : -1 ;
			
			if(d.getType().getKind() == Struct.Int || d.getType().getKind() == Struct.Char){
				
				if(d.getLevel() == 0 || d.getKind() == Obj.Fld || d.getKind() == Obj.Elem){ //it is not local
					if(d.getKind() == Obj.Fld){
						Code.put(Code.dup);
					} else if(d.getKind() == Obj.Elem){
						Code.put(Code.dup2);
					}
					
					Code.load(d);
					Code.loadConst(1);
					Code.put(op);
					Code.store(d);
				//} else if (d.getKind() == Obj.Fld) {
					//parser.report_fatal_error(dleft+" : not yet implemented", null);
				} else {
					Code.put(Code.inc); Code.put(d.getAdr()); Code.put(diff);
				}
			} else { 
				parser.report_semanthic_error(dleft + " : Only int and char types can be de/increamented", null);
			}
		}
		
		int sizeOf(Struct st){
			if(st == null) return 0;
			
			if(st.getKind() == Struct.None) return 0;
			else if(st.getKind() == Struct.Array) return 4;
			else if(st.getKind() == Struct.Class) return inheritanceSizeOf(st);
			else return 4;
		}
		
		int inheritanceSizeOf(Struct derived){
			int s = 0;
			do {
				s += derived.getNumberOfFields();
				derived = derived.getElemType();		
			}while(derived != null);
			return s*4;
		}
		
		Obj findLocal(Obj container, String localName){
		
			if(("this".equals(container.getName())) ){// || (container == currentClass && container != Tab.noObj)){
				return findMemberOfCurrentClass(localName);
			} else {
				Collection<Obj> locals = container.getLocalSymbols();
				for(Obj l : locals){
					if(l.getName().equals(localName)){
						return l;
					}
				}
			}
			if(container.getType().getKind() == Struct.Class){
				return findInheritedMember(container.getType(), localName);
			}
			
			return Tab.noObj;
			
		}
		
		boolean assignableTo(Struct src, Struct dest){
			if(src.getKind() != Struct.Class){
				return src.assignableTo(dest);
			}
		
			do {
				if(src.assignableTo(dest)){
					return true;
				}
				src = src.getElemType();
			} while(src != null);
			
			return false;
		}

		Obj getLocalAt(Obj ob, int pos){
			Object[] objs = (ob.getLocalSymbols().toArray());
			if(objs.length <= pos) return Tab.noObj;
			else return (Obj)objs[pos];
		}
		
		Obj findMemberOfCurrentClass(String name){
			Obj res = Tab.currentScope.getOuter().findSymbol(name);
			if(res != null){
				return res;
			}
			if(currentClass.getType().getElemType() != null){
				return findInheritedMember(currentClass.getType().getElemType(), name);
			}
			return Tab.noObj;
			
		}
		
		Obj findInheritedMember(Struct derivedClass, String name) {
			Struct cc = derivedClass;
			do {
				Obj obj = cc.getMembersTable().searchKey(name);
				
				if(obj != null){
					return obj;
				}
			
				cc = cc.getElemType();
			} while(cc != null);
			
			return Tab.noObj;
		}
		
		
		void openScope(){
			currentLevel++;
			Tab.openScope();
		}
		
		void closeScope(){
			currentLevel--;
			Tab.closeScope();
		}
		

  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // Mulop ::= MOD 
            {
              Integer RESULT =null;
		 RESULT = Code.rem; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Mulop",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // Mulop ::= DEVIDE 
            {
              Integer RESULT =null;
		 RESULT = Code.div; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Mulop",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // Mulop ::= TIMES 
            {
              Integer RESULT =null;
		 RESULT = Code.mul; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Mulop",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // Addop ::= MINUS 
            {
              Integer RESULT =null;
		 RESULT = Code.sub; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Addop",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // Addop ::= PLUS 
            {
              Integer RESULT =null;
		 RESULT = Code.add; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Addop",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // Relop ::= LESS_OR_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.le; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // Relop ::= LESS 
            {
              Integer RESULT =null;
		 RESULT = Code.lt; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // Relop ::= GREATER_OR_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.ge; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // Relop ::= GREATER 
            {
              Integer RESULT =null;
		 RESULT = Code.gt; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // Relop ::= NOT_EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.ne; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // Relop ::= EQUAL 
            {
              Integer RESULT =null;
		 RESULT = Code.eq; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Relop",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // DesignatorRestPart ::= DOT IDENT 
            {
              Obj RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
					 	//pristup polju ili poziv metode currentDesignator-a
					 	parser.report_info(ileft + " : currentDesignator " + currentDesignator.getType().getKind() + " " + currentDesignator.getName(), null);
					 	Obj local = findLocal(currentDesignator, i);
					 	parser.report_info(ileft+" : Accessing member " + i + " of " + kinds[currentDesignator.getKind()] + " " + currentDesignator.getName() + " found " + kinds[local.getKind()] + " " + local.getName() + " level=" + local.getLevel(), null);
					 	
					 	initCurrentThis(local, ileft);
					 	RESULT = local;
					 	
					 	Code.load(currentDesignator);
					 	
					 	currentDesignator = RESULT;
					 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DesignatorRestPart",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // DesignatorRestPart ::= LBRACKET error RBRACKET 
            {
              Obj RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DesignatorRestPart",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // DesignatorRestPart ::= LBRACKET NT$15 Expr RBRACKET 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$15
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
					 	//indeksiranje currentDesignator-a
					 	if(e.getKind() != Struct.Int) { RESULT = Tab.noObj; parser.report_info(eleft+" : Array index must be of type int.",null); }
					 	else if (currentDesignator.getType().getKind()==Struct.Array){
					 		RESULT=new Obj(Obj.Elem, "", currentDesignator.getType().getElemType());
					 	} else {
					 		parser.report_info(eleft+" : Only arrays can be indexed", null);
					 		RESULT = Tab.noObj;
					 	}
					 	
					 	currentDesignator = RESULT;
					 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DesignatorRestPart",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // NT$15 ::= 
            {
              Obj RESULT =null;
 Code.load(currentDesignator);  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$15",62, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // DesignatorRest ::= DesignatorRestPart 
            {
              Obj RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Obj r = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = r; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DesignatorRest",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // DesignatorRest ::= DesignatorRest DesignatorRestPart 
            {
              Obj RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Obj r = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = r; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DesignatorRest",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // Designator ::= IDENT NT$14 DesignatorRest 
            {
              Obj RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (Obj) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Obj r = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			 	RESULT = r;
			 	if(currentDesignator.getKind() != Obj.Meth) popCurrentThis(); //otherwise leave it for MethodCall to use it and then pop it
			 	popCurrentDesignator();
			 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Designator",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // NT$14 ::= 
            {
              Obj RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
 
			 	pushCurrentDesignator();
			 	pushCurrentThis();
			 	Obj ob = Tab.find(i);
			 	
			 	if(ob.getKind() == Obj.Fld){
			 		currentDesignator = Tab.find("this");
					Code.load(currentDesignator);
				}
			 	
			 	initCurrentThis(ob, ileft);
			 	currentDesignator = ob;
			 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$14",61, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // Designator ::= IDENT 
            {
              Obj RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
					pushCurrentDesignator();
					pushCurrentThis();
					Obj ob;
					ob = Tab.find(i);
						
					if(ob != Tab.noObj){
						parser.report_info(ileft+" : Used " + kinds[ob.getKind()] + " " + i + " level: " + ob.getLevel(), null);
					}

					if(ob.getKind() == Obj.Fld){
				 		currentDesignator = Tab.find("this");
						Code.load(currentDesignator);
					}

					RESULT = ob;
					popCurrentThis();
					popCurrentDesignator();
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Designator",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // ParensAndActPars ::= LPAREN ActPars RPAREN 
            {
              Integer RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT = n; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ParensAndActPars",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // ParensAndActPars ::= LPAREN RPAREN 
            {
              Integer RESULT =null;
		 RESULT = (thisForMethCall != Tab.noObj) ? new Integer(1) : new Integer(0); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ParensAndActPars",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // MethodCall ::= Designator NT$13 ParensAndActPars 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			if(d.getKind() != Obj.Meth || d.getLevel() != n) {
				parser.report_error(dleft+" : number of parameters does not match. " + d.getLevel() + " != " + n + " | " + thisForMethCall.getName() ,null);
				RESULT = Tab.noType;
			} else {
				RESULT = d.getType();
			}
			
			parser.report_info("Calling method " + currentMethBeingCalled.getName() + " @ " + currentMethBeingCalled.getAdr(),null);
			int destAddr = currentMethBeingCalled.getAdr() - Code.pc;
			Code.put(Code.call);
			Code.put2(destAddr);
			popThisForMethCallStack();
			popCurrentThis();
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MethodCall",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // NT$13 ::= 
            {
              Struct RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;

			pushThisForMethCallStack();
			if(d.getKind() == Obj.Meth){
				if(currentThis != Tab.noObj){
					thisForMethCall = currentThis;
				} else if (currentClass != Tab.noObj && findMemberOfCurrentClass(d.getName()) == d){
					thisForMethCall = currentClass;
					Code.load(Tab.find("this"));
				}
				currentMethBeingCalled = d; currentActPar = 0;
			} else {
				parser.report_info(dleft+" : " + d.getName() + " is not method.", null);
				//currentMethBeingCalled = null;
			}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$13",60, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // Factor ::= MethodCall 
            {
              Struct RESULT =null;
		int mtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int mtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct mt = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = mt; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // Factor ::= Designator 
            {
              Struct RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = d.getType(); Code.load(d); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // Factor ::= NEW Type LBRACKET Expr RBRACKET 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			if(e.getKind() == Struct.Int) {
				RESULT = new Struct(Struct.Array, t);
				int ischar = t.getKind() == Struct.Char ? 0 : 1 ; 
				Code.put(Code.newarray); Code.put(ischar);
			} else {
				RESULT = Tab.noType; parser.report_info(eleft+" : Array index must be of type int.",null);
			}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // Factor ::= NEW Type 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 parser.nObjInsts++; RESULT = t; Code.put(Code.new_); Code.put2(sizeOf(t)); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // Factor ::= LPAREN Expr RPAREN 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 RESULT  = t; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // Factor ::= Literal 
            {
              Struct RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LiteralHolder l = (LiteralHolder)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = l.type; Code.loadConst(l.getIntValue()); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Factor",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // Term ::= Factor 
            {
              Struct RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct f = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = f; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Term",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // Term ::= Term Mulop Factor 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Integer m = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct f = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			if (t.getKind() == Struct.Int && f.getKind() == Struct.Int) {
				RESULT = t;
			} else {
				RESULT = Tab.noType;
			}
			
			Code.put(m);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Term",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // ExprRest ::= Term 
            {
              Struct RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = t; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExprRest",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // ExprRest ::= ExprRest Addop Term 
            {
              Struct RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Struct r = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
				if(r.compatibleWith(t)){
					RESULT = r;
				} else {
					RESULT = Tab.noType;
				}
				
				Code.put(op);
				
			
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ExprRest",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // Expr ::= ExprRest 
            {
              Struct RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct r = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = r; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expr",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // Expr ::= MINUS ExprRest 
            {
              Struct RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct r = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = r; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Expr",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // CondFact ::= Expr 
            {
              Integer RESULT =null;
		int etleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int etright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct et = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 if(et.getKind() != Struct.Bool) parser.report_semanthic_error(etleft + " : Bool type expected!",null); RESULT = Code.eq; Code.loadConst(1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CondFact",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // CondFact ::= Expr Relop Expr 
            {
              Integer RESULT =null;
		int ftleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int ftright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Struct ft = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int etleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int etright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct et = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			RESULT = op;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CondFact",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // CondTerm ::= CondFact 
            {
              Integer RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			//The last in Term
			//just last Fact in Term
			Code.putFalseJump(Code.inverse[op], 0);
			condTerms.getLast().addLast(new AdrDest(Code.pc - 2, AdrDest.BEGIN));
			RESULT = op;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CondTerm",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // CondTerm ::= CondFact NT$12 LOGICAL_AND CondTerm 
            {
              Integer RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Integer) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int ttleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ttright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer tt = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = tt; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CondTerm",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // NT$12 ::= 
            {
              Integer RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;

			Code.putFalseJump(op, 0);
			//non of the above :)
			condTerms.getLast().addLast(new AdrDest(Code.pc - 2, AdrDest.NEXT));
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$12",59, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // Condition ::= CondTerm 
            {
              Struct RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
				//The last term in cond
				
				//Revert what last Fact did, because he didn't know that he's last
				Code.pc -= 3;
				condTerms.getLast().removeLast();
				
				//now fix it
				Code.putFalseJump(op, 0);
				condTerms.getLast().addLast(new AdrDest(Code.pc - 2, AdrDest.NEXT));
				
				//This is obsolite now
				//Code.putJump(0);
				//condTerms.getLast().addLast(new AdrDest(Code.pc - 2, AdrDest.NEXT));
				
				beginIfAddress = Code.pc;
			
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Condition",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // Condition ::= CondTerm NT$11 LOGICAL_OR Condition 
            {
              Struct RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (Struct) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Condition",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // NT$11 ::= 
            {
              Struct RESULT =null;
 condTerms.addLast(new LinkedList<AdrDest>()); condTermAddresses.addLast(Code.pc); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$11",58, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // ActPars ::= ActPars error RPAREN 
            {
              Integer RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ActPars",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // ActPars ::= ActPars error COMMA 
            {
              Integer RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ActPars",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // ActPars ::= Expr 
            {
              Integer RESULT =null;
		int ptleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ptright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct pt = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = (thisForMethCall != Tab.noObj) ? new Integer(2) : new Integer(1); if(!assignableTo(getLocalAt(currentMethBeingCalled, RESULT-1).getType(), pt)){parser.report_semanthic_error(ptleft +" : Parameter " + RESULT + " does not match required type" + currentMethBeingCalled.getName() + " " + currentThis.getName() + " " + thisForMethCall.getName(), null);} 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ActPars",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // ActPars ::= ActPars COMMA Expr 
            {
              Integer RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ptleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int ptright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Struct pt = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = n + 1; if(!assignableTo(getLocalAt(currentMethBeingCalled, RESULT-1).getType(), pt)){parser.report_semanthic_error(ptleft +" : Parameter " + RESULT + " does not match required type" + currentMethBeingCalled.getName() + " " + currentThis.getName() + " " + thisForMethCall.getName(), null);} 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ActPars",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // LoopHeader ::= WHILE error RPAREN 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LoopHeader",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // LoopHeader ::= WHILE ParensAndCondition 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LoopHeader",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // OtherStatement ::= SEMI 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // OtherStatement ::= DO Statement WHILE error RPAREN 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // OtherStatement ::= DO Statement WHILE LPAREN Condition RPAREN SEMI 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // OtherStatement ::= LBRACE StatementList RBRACE 
            {
              Object RESULT =null;
		 if(parser.inMain) { parser.nStatementBlocks++; parser.nSimpleMainStatements--; }
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // OtherStatement ::= RETURN Expr SEMI 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 if(assignableTo(e, currentMeth.getType())){ Code.put(Code.exit); Code.put(Code.return_); returnExists = true; } else { parser.report_semanthic_error(eleft + " : Type not assignable to return type.", null); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // OtherStatement ::= RETURN SEMI 
            {
              Object RESULT =null;
		 Code.put(Code.exit); Code.put(Code.return_); returnExists = true; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // OtherStatement ::= BREAK SEMI 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // OtherStatement ::= PRINT LPAREN Expr COMMA NUMBER_LITERAL RPAREN SEMI 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
					if(e.getKind() == Struct.Int){
						Code.loadConst((Integer)n);
						Code.put(Code.print);
					} else if (e.getKind() == Struct.Char) {
						Code.loadConst((Integer)n);
						Code.put(Code.bprint);
					} else {
						parser.report_semanthic_error(eleft + " : Not implemented.", null);
					}
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // OtherStatement ::= PRINT LPAREN Expr RPAREN SEMI 
            {
              Object RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
					if(e.getKind() == Struct.Int){
						Code.loadConst(1);
						Code.put(Code.print);
					} else if (e.getKind() == Struct.Char) {
						Code.loadConst(1);
						Code.put(Code.bprint);
					} else {
						parser.report_semanthic_error(eleft + " : Not implemented.", null);
					}
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // OtherStatement ::= READ LPAREN Designator RPAREN SEMI 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
					if(d.getType().getKind() == Struct.Int){
						Code.put(Code.read);
						Code.store(d);
					} else if (d.getType().getKind() == Struct.Char) {
						Code.put(Code.bread);
						Code.store(d);
					} else {
						parser.report_semanthic_error(dleft + " : Only int and char types can be read.", null);
					}
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // OtherStatement ::= MethodCall NT$10 SEMI 
            {
              Object RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // NT$10 ::= 
            {
              Object RESULT =null;
 if(parser.inMain){parser.nSimpleMainStatements--; parser.nFuncCallsInMain++; } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$10",57, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // OtherStatement ::= Designator DECREAMENT SEMI 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
					doIncOrDec(d, Code.sub, dleft);
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // OtherStatement ::= Designator INCREAMENT SEMI 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		 
					doIncOrDec(d, Code.add, dleft);
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // OtherStatement ::= error ASSIGNMENT Expr SEMI 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // OtherStatement ::= Designator ASSIGNMENT error SEMI 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // OtherStatement ::= Designator ASSIGNMENT Expr SEMI 
            {
              Object RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Obj d = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Struct e = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
					if(assignableTo(e, d.getType())){
						Code.store(d);
					} else {
						parser.report_semanthic_error(dleft + " : Types are not assignable.",null);
					}
					
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OtherStatement",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // ClosedIf ::= LoopHeader ClosedIf 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ClosedIf",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // ClosedIf ::= IF error RPAREN ClosedIf ELSE ClosedIf 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ClosedIf",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // ClosedIf ::= IF ParensAndCondition ClosedIf Else ClosedIf 
            {
              Object RESULT =null;
		int elseAdrleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int elseAdrright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Integer elseAdr = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Code.fixup(elseAdr); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ClosedIf",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // ClosedIf ::= NT$9 OtherStatement 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ClosedIf",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // NT$9 ::= 
            {
              Object RESULT =null;
 if(parser.inMain){ parser.nSimpleMainStatements++;}
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$9",56, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // OpenIf ::= LoopHeader OpenIf 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OpenIf",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // OpenIf ::= IF error RPAREN ClosedIf ELSE OpenIf 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OpenIf",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // OpenIf ::= IF ParensAndCondition ClosedIf Else OpenIf 
            {
              Object RESULT =null;
		int elseAdrleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int elseAdrright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Integer elseAdr = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 Code.fixup(elseAdr); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OpenIf",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // OpenIf ::= IF error RPAREN Statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OpenIf",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // OpenIf ::= IF ParensAndCondition Statement 
            {
              Object RESULT =null;
		
			patchCondition();
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OpenIf",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // Statement ::= ClosedIf 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // Statement ::= OpenIf 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Statement",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // ParensAndCondition ::= LPAREN NT$7 Condition NT$8 RPAREN 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ParensAndCondition",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // NT$8 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

						 
					
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$8",55, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // NT$7 ::= 
            {
              Object RESULT =null;

						condTerms = new LinkedList<Deque<AdrDest>>();
						condTerms.addLast(new LinkedList<AdrDest>());
						condTermAddresses = new LinkedList<Integer>();
					
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$7",54, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // Else ::= ELSE 
            {
              Integer RESULT =null;
		 Code.putJump(0); RESULT = Code.pc -2; patchCondition(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Else",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // StatementList ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("StatementList",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // StatementList ::= StatementList Statement 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("StatementList",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // Type ::= IDENT 
            {
              Struct RESULT =null;
		int typeNameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int typeNameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String typeName = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			Obj typeNode = Tab.find(typeName);
		
			if(typeNode == Tab.noObj)
			{
				parser.report_error("No type " + typeName + " in symbol table.", null);
				RESULT = Tab.noType;
			}
			else{
				if(typeNode.getKind() == Obj.Type){
					RESULT = typeNode.getType();
				}
				else{
					parser.report_error("Error in line " + typeNameleft + " : Name " + typeName + " is not type name.", null);
					RESULT = Tab.noType;
				}
			}
			currentType = RESULT;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Type",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // FormPar ::= Type IDENT 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Struct t = (Struct)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			Obj var = Tab.insert(Obj.Var, i, t);
			var.setLevel(currentLevel);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FormPar",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // FormParList ::= error RPAREN 
            {
              Integer RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FormParList",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // FormParList ::= error COMMA 
            {
              Integer RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FormParList",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // FormParList ::= FormPar 
            {
              Integer RESULT =null;
		 RESULT = new Integer(1); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FormParList",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // FormParList ::= FormPar COMMA FormParList 
            {
              Integer RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = n + 1; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FormParList",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // FormPars ::= 
            {
              Integer RESULT =null;
		 RESULT = new Integer(0); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FormPars",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // FormPars ::= FormParList 
            {
              Integer RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer n = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = n; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FormPars",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // MethodDeclRest ::= IDENT NT$4 LPAREN NT$5 FormPars RPAREN VarDeclList LBRACE NT$6 StatementList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-10)).value;
		int levelleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int levelright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Integer level = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		
					parser.inProgramParams++;
					parser.inMain = false;
					
					Tab.chainLocalSymbols(currentMeth);
					closeScope();
					
					if(!returnExists && currentMeth.getType() == Tab.noType) {
							Code.put(Code.exit); Code.put(Code.return_);
					}
					
					//stop execution if there return statement is skipped
					Code.put(Code.trap); Code.put(1);
					
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MethodDeclRest",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-10)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // NT$6 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int levelleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int levelright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Integer level = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
 
					int nvars = Tab.currentScope.getnVars();
					if(currentClass != Tab.noObj) { level++; }
					currentMeth.setLevel(level); //number of parameters
					Code.put(Code.enter); Code.put(currentMeth.getLevel()); Code.put(nvars);
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$6",53, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // NT$5 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
 if(currentClass != Tab.noObj){ Obj var = Tab.insert(Obj.Var, "this", currentClass.getType());	var.setLevel(currentLevel); } 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$5",52, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // NT$4 ::= 
            {
              Object RESULT =null;
		int methNameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int methNameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String methName = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;

				 if(parser.inProgramParams>0) { parser.nDefProgramFuncs++; if("main".equals(methName)) { parser.inMain = true; Code.mainPc = Code.pc; }}
				 else parser.nDefClassMeths++;
				 parser.inProgramParams--; 
				 
				 currentMeth = Tab.insert(Obj.Meth, methName, currentType);
				 currentMeth.setAdr(Code.pc);
				 parser.report_info("Declaring method " + currentMeth.getName() + " @ " + currentMeth.getAdr(), null);
				  
				 returnExists = false;
				 openScope();
				 isVoid = 0;
				 
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$4",51, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // MethodDecl ::= VOID NT$3 MethodDeclRest 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MethodDecl",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // NT$3 ::= 
            {
              Object RESULT =null;
 isVoid = 1; currentType = Tab.noType; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$3",50, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // MethodDecl ::= Type MethodDeclRest 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MethodDecl",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // MethodDeclList ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // MethodDeclList ::= MethodDecl MethodDeclList 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("MethodDeclList",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // ClassMemberDecl ::= MethodDecl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ClassMemberDecl",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // ClassMemberDecl ::= VarDecl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ClassMemberDecl",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // ClassMemberDeclList ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ClassMemberDeclList",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // ClassMemberDeclList ::= error ClassMemberDeclList RBRACE 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ClassMemberDeclList",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // ClassMemberDeclList ::= ClassMemberDecl ClassMemberDeclList 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ClassMemberDeclList",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // extendsStm ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("extendsStm",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // extendsStm ::= EXTENDS error LBRACE 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("extendsStm",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // extendsStm ::= EXTENDS IDENT 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
				Obj superClass = Tab.find(i);
				
				parser.dbg("extends " + kinds[superClass.getKind()] + " " + superClass.getName());
				
				currentClass.getType().setElementType(superClass.getType());
				/* TODO offsets and things */
				
			
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("extendsStm",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // ClassDecl ::= CLASS IDENT NT$1 extendsStm LBRACE NT$2 ClassMemberDeclList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		 parser.inProgramParams++; Tab.chainLocalSymbols(currentClass); Tab.chainLocalSymbols(currentClass.getType()); currentClass = Tab.noObj; closeScope(); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ClassDecl",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // NT$2 ::= 
            {
              Object RESULT =(Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
 parser.inProgramParams--; openScope(); currentClass.setLevel(currentLevel); /* used for offset - inherited members size */ currentClass.setAdr(sizeOf(currentClass.getType().getElemType())); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$2",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // NT$1 ::= 
            {
              Object RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;

	parser.nDeclClasses++;
	currentClass = Tab.insert(Obj.Type, i, new Struct(Struct.Class));
	RESULT = currentClass;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$1",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // VarDeclName ::= IDENT LBRACKET RBRACKET 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		
					if(parser.inProgramParams>0) parser.nDeclGlobSimpleVars++;
					Obj var;
					
					Struct t = new Struct(Struct.Array, currentType);
					
					if(currentLevel == currentClass.getLevel() && currentClass != Tab.noObj){ //we're in class
						var = Tab.insert(Obj.Fld, name, t);
						var.setAdr(var.getAdr() + currentClass.getAdr());
						
					} else {
						var = Tab.insert(Obj.Var, name, t);
						
					}
					var.setLevel(currentLevel);
					parser.report_info(nameleft+" : Declared "+ kinds[var.getKind()] +" "+name, null);
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDeclName",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // VarDeclName ::= IDENT 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
					if(parser.inProgramParams>0) parser.nDeclGlobSimpleVars++;
					Obj var;

					if(currentLevel == 1 && currentClass != Tab.noObj){ //we're in class
						var = Tab.insert(Obj.Fld, name, currentType);
						var.setAdr(var.getAdr() + currentClass.getAdr());
					} else {
						var = Tab.insert(Obj.Var, name, currentType);
						
					}
					var.setLevel(currentLevel);
					parser.report_info(nameleft+" : Declared "+ kinds[var.getKind()] +" "+name, null);
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDeclName",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // VarDeclNames ::= VarDeclName 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDeclNames",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // VarDeclNames ::= VarDeclNames COMMA VarDeclName 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDeclNames",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // VarDecl ::= Type error LBRACE 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDecl",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // VarDecl ::= Type error SEMI 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDecl",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // VarDecl ::= Type VarDeclNames SEMI 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDecl",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // VarDeclList ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDeclList",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // VarDeclList ::= VarDecl VarDeclList 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("VarDeclList",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // Literal ::= STRING_LITERAL 
            {
              LiteralHolder RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new LiteralHolder(n, Parser.String); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Literal",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // Literal ::= CHAR_LITERAL 
            {
              LiteralHolder RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new LiteralHolder(n, Tab.charType); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Literal",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // Literal ::= BOOL_LITERAL 
            {
              LiteralHolder RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new LiteralHolder(n, Parser.Bool); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Literal",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // Literal ::= NUMBER_LITERAL 
            {
              LiteralHolder RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new LiteralHolder(n, Tab.intType); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Literal",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // ConstDeclName ::= IDENT ASSIGNMENT Literal 
            {
              Object RESULT =null;
		int nameleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int nameright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String name = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		LiteralHolder l = (LiteralHolder)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 
					if(parser.inProgramParams>0) parser.nDeclGlobSimpleConsts++; 
					Obj con = Tab.insert(Obj.Con, name, currentType);
					con.setLevel(currentLevel);
					con.setAdr(l.getIntValue());
					
					parser.report_info(nameleft+" : Declared constant "+name,null);
				
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstDeclName",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ConstDeclNames ::= ConstDeclName 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstDeclNames",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // ConstDeclNames ::= ConstDeclNames COMMA ConstDeclName 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstDeclNames",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // ConstDecl ::= CONST error SEMI 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstDecl",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // ConstDecl ::= CONST Type ConstDeclNames SEMI 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ConstDecl",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // ProgParamDeclPart ::= ClassDecl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ProgParamDeclPart",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // ProgParamDeclPart ::= VarDecl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ProgParamDeclPart",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // ProgParamDeclPart ::= ConstDecl 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ProgParamDeclPart",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // ProgParamDeclList ::= 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ProgParamDeclList",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // ProgParamDeclList ::= ProgParamDeclList ProgParamDeclPart 
            {
              Object RESULT =null;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ProgParamDeclList",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // ProgName ::= IDENT 
            {
              Obj RESULT =null;
		int pnleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pnright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String pn = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
	parser.report_info("Program: " + pn, null);
	RESULT = Tab.insert(Obj.Prog, pn, Tab.noType);
	RESULT.setLevel(currentLevel);
	openScope(); 

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ProgName",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // $START ::= Program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // Program ::= PROGRAM ProgName NT$0 ProgParamDeclList LBRACE MethodDeclList RBRACE 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		 
	Code.dataSize = Tab.currentScope.getnVars();
	parser.inProgramParams--;
	Tab.chainLocalSymbols(p);
	closeScope();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("Program",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // NT$0 ::= 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Obj p = (Obj)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
 parser.inProgramParams++; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("NT$0",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

