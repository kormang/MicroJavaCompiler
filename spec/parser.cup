//import statements

package net.etfbl.kki;

import java_cup.runtime.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;

//action & parser code

parser code {:

	//level A
	int nDeclGlobSimpleVars;
	int nDeclGlobSimpleConsts;
	int nSimpleMainStatements;
	int nStatementBlocks;
	
	//level B
	int nDefProgramFuncs;
	int nDeclGlobArrays;
	int nFuncCallsInMain;
	
	//level C
	int nDeclClasses;
	int nDefClassMeths;
	int nObjInsts;
	
	//flags
	int inProgramParams;
	boolean inMain;
	
	public void dbg(Object o){
		System.out.println(o);
	}
	
	public void report_error(String message, Object info){
		StringBuilder builder = new StringBuilder(message);
		if(info instanceof Symbol){
			builder.append(" in line ").append(((Symbol)info).left);
		}
		System.out.println(builder.toString());
	}
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception{
		done_parsing();
		report_error(message, info);
	}

	public void syntax_error(Symbol cur_token){
		report_error("\nSyntax error", cur_token);
	}

	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception{
		report_fatal_error("\nFatal error!", cur_token);
	}

	public void report_info(String message, Object info){
		StringBuilder builder = new StringBuilder(message);
		if(info instanceof Symbol){
			builder.append(" in line ").append(((Symbol)info).left);
		}
		System.out.println(builder.toString());
	}

:}

scan with {:
	Symbol symbol = this.getScanner().next_token();
	/*if(symbol != null && symbol.value != null){
		System.out.println(symbol.toString() + " " + symbol.value.toString());
	}*/
	if(symbol.sym == sym.INVALID){
		System.err.println("INVALID symbol");
		symbol = this.getScanner().next_token();
	}
	return symbol;
:}

init with {:

:}

//keyword terminals
terminal PROGRAM, PRINT, RETURN, VOID, CLASS, EXTENDS, NEW, IF, ELSE, WHILE, READ ;
terminal BREAK, DO, CONST ;

//operator terminals
terminal LOGICAL_OR, LOGICAL_AND, INCREAMENT, DECREAMENT, EQUAL, NOT_EQUAL, GREATER ;
terminal GREATER_OR_EQUAL, LESS, LESS_OR_EQUAL, PLUS, MINUS, ASSIGNMENT, TIMES, DEVIDE ;
terminal MOD, SEMI, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, RBRACKET, LBRACKET, DOT ;

//literal terminals
terminal NUMBER_LITERAL, BOOL_LITERAL, CHAR_LITERAL, STRING_LITERAL ;

//other terminals
terminal INVALID ;
terminal String IDENT ;

//non-terminals:
non terminal Program, ProgParamDeclList, MethodDeclList, ProgParamDeclPart, ConstDecl, VarDecl, ClassDecl, ConstDeclNames, ConstDeclName ;
non terminal Literal, VarDeclList, VarDeclNames, VarDeclName, extendsStm, ClassMemberDeclList, ClassMemberDecl, MethodDecl, MethodDeclRest ;
non terminal FormPars;
non terminal FormParList, FormPar ;
non terminal Designator, Expr, Condition, Statement, StatementList, OtherStatement, OpenIf, ClosedIf ;
non terminal ActPars, CondTerm, CondFact, Relop, ExprRest, Addop, Term, Mulop, Factor ;
non terminal DesignatorRest, DesignatorRestPart ;
non terminal LoopHeader ;

non terminal Obj ProgName ;
non terminal Struct Type ;

//grammar

Program ::= PROGRAM ProgName:p {: parser.inProgramParams++; :} ProgParamDeclList LBRACE MethodDeclList RBRACE 
{: 
	parser.inProgramParams--;

	Tab.chainLocalSymbols(p);
	Tab.closeScope();
:};

ProgName ::= IDENT:pn {:
	System.out.println(pn);
	Tab.openScope();
	RESULT = Tab.insert(Obj.Prog, pn, Tab.noType); 
:}
;

ProgParamDeclList ::= ProgParamDeclList ProgParamDeclPart | /* epsilon */ ;
ProgParamDeclPart ::= ConstDecl | VarDecl | ClassDecl ;

ConstDecl ::= CONST Type ConstDeclNames SEMI ;
ConstDeclNames ::= ConstDeclNames COMMA ConstDeclName | ConstDeclName ;
ConstDeclName ::= IDENT ASSIGNMENT Literal {: if(parser.inProgramParams>0) parser.nDeclGlobSimpleConsts++; :};


Literal ::= NUMBER_LITERAL | BOOL_LITERAL | CHAR_LITERAL | STRING_LITERAL ;

VarDeclList ::= VarDecl VarDeclList | /* epsilon */ ;
VarDecl ::= Type VarDeclNames SEMI ;
VarDeclNames ::= VarDeclNames COMMA VarDeclName | VarDeclName ;
VarDeclName ::= IDENT:i {: if(parser.inProgramParams>0) parser.nDeclGlobSimpleVars++; :} | IDENT:i LBRACKET RBRACKET{: if(parser.inProgramParams>0) parser.nDeclGlobArrays++; :} ;

ClassDecl ::= CLASS IDENT:i {: parser.nDeclClasses++; :} extendsStm LBRACE {: parser.inProgramParams--; :} ClassMemberDeclList RBRACE {: parser.inProgramParams++; :} ;
extendsStm ::= EXTENDS IDENT:i {: parser.dbg("extends " + i);:} | /* epsilon */ ;
ClassMemberDeclList ::= ClassMemberDecl ClassMemberDeclList | /* epsilon */ ;
ClassMemberDecl ::= VarDecl | MethodDecl ;

MethodDeclList ::= MethodDecl MethodDeclList | /* epsilon */;
MethodDecl ::= Type MethodDeclRest  | VOID MethodDeclRest;
MethodDeclRest ::= IDENT:methName 
{:
 if(parser.inProgramParams>0) { parser.nDefProgramFuncs++; if("main".equals(methName)) parser.inMain = true; }
 else parser.nDefClassMeths++;
 parser.inProgramParams--; 
 
:} 
LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE {: parser.inProgramParams++; parser.inMain = false; :} ;


FormPars ::= FormParList | /* epsilon */ ;
FormParList ::= FormPar COMMA FormParList | FormPar ;
FormPar ::= Type IDENT ;


Type ::= IDENT:typeName
{:
	Obj typeNode = Tab.find((String)typeName);

	if(typeNode == Tab.noObj)
	{
		parser.report_error("No type " + typeName + " in symbol table.", null);
		RESULT = Tab.noType;
	}
	else{
		if(typeNode.getKind() == Obj.Type){
			RESULT = typeNode.getType();
		}
		else{
			parser.report_error("Error in line " + typeNameleft + " : Name " + typeName + " is not type name.", null);
			RESULT = Tab.noType;
		}
	}
:};

StatementList ::= StatementList Statement | /* epsilon */ ;

Statement ::= OpenIf | ClosedIf ;

OpenIf ::= IF LPAREN Condition RPAREN Statement
		| IF LPAREN Condition RPAREN ClosedIf ELSE OpenIf
		| LoopHeader OpenIf
		;
		
ClosedIf ::= OtherStatement
		 |	LPAREN Condition RPAREN ClosedIf ELSE ClosedIf
		 | LoopHeader ClosedIf
		 ;

OtherStatement ::= Designator ASSIGNMENT Expr SEMI
				| Designator INCREAMENT SEMI
				| Designator DECREAMENT SEMI
				| Designator LPAREN ActPars RPAREN SEMI
				| READ LPAREN Designator RPAREN SEMI
				| PRINT LPAREN Expr RPAREN SEMI
				| PRINT LPAREN Expr COMMA NUMBER_LITERAL RPAREN SEMI
				| BREAK SEMI
				| RETURN SEMI
				| RETURN Expr SEMI
				| LBRACE StatementList RBRACE
				| DO Statement WHILE LPAREN Condition RPAREN SEMI
				| SEMI
				;

LoopHeader ::= WHILE LPAREN Condition RPAREN
			;


			
ActPars ::= ActPars COMMA Expr | Expr ;
Condition ::= Condition LOGICAL_OR CondTerm | CondTerm ;
CondTerm ::= CondTerm LOGICAL_AND CondFact | CondFact ;
CondFact ::= CondFact Relop Expr | Expr ;
Expr ::= MINUS ExprRest | ExprRest;
ExprRest ::= ExprRest Addop Term | Term ;
Term ::= Term Mulop Factor | Factor ;
Factor ::= Literal 
		| LPAREN Expr RPAREN
		| NEW Type
		| NEW Type LBRACKET Expr RBRACKET
		| Designator
		| Designator LPAREN ActPars RPAREN
		;
		
Designator ::= IDENT | IDENT DesignatorRest;
DesignatorRest ::= DesignatorRest DesignatorRestPart | DesignatorRestPart ;
DesignatorRestPart ::= LBRACKET Expr RBRACKET | DOT IDENT ;

Relop ::= EQUAL | NOT_EQUAL | GREATER | GREATER_OR_EQUAL | LESS | LESS_OR_EQUAL ;
Addop ::= PLUS | MINUS ;
Mulop ::= TIMES | DEVIDE | MOD ;










